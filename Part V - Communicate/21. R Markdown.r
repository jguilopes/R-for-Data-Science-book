### R MARKDOWN ###

# R Markdown provides a unified authoring framework for data science, combining your code, its results, and your prose commentary.
# R Markdown documents are fully reproducible and support dozens of output formats, like PDFs, Word files, slideshows, and more.

# R Markdown files are designed to be used in three ways:

  ##  For communicating to decision makers, who want to focus on the conclusions, not the code behind the analysis.
  ## For collaborating with other data scientists, who are interested in both you conclusions, and how you reached them.
  ## As an environment in which to do data science, as a modern day lab notebook where you can capture not only what you did,
    ### but also what you were thinking. 

# R Markdown integrates a number of R packages and external tools.
  ## This means that helpis, by and large, not available through ?.
# Instead, as you work through this chapter, and use R Markdown in the future, keep these resources close to hand:

  ## R Markdown Cheat Sheet: RStudio -> help -> Cheatsheets -> R Markdown Cheat Sheet
  ## R Markdown Reference Guide: RStudio -> help -> Cheatsheets -> R Markdown Reference Guide

# You need the 'rmarkdown' package, but you don't need to explicitly install it or load it, as RStudio auto does this.


# R MARKDOWN BASICS

  ## An R Markdown file has the extension .Rmd
  ## It can be a plain-text file that may contains three important types of content:
    ### 1. An (optional) YAML header surrounded by --- 
    ### 2. Chunks of R code surrounded by ```
    ### 3. Text mixed with simple text formatting like '# heading' and _italics_

  ## When you open an .Rmd, you get a notebook interface where code and output are interleaved.
  ## You can run each code chunk by clicking the Run icon (it looks like a play button), or pressing Ctrl-Shift-Enter
  ## RStudio executes the code and displays the results inline with the code.

  ## To produce a complete report containing all text, code, and results, click "Knit" or press Ctrl-Shift-K.
  ## You can also do this programmatically with rmarkdown::render("1-example.Rmd").
  ## This will display the report in the viewer pane, and create a self-contained HTML file that you can share with others.

  ## When you knit the document, R Markdown sends the .Rmd file to knitr (http://yihui.name/knitr), which executes
    ### all of the code chunks and creates a new Markdown (.md) document that includes the code and its output.
  ## The Markdown file generated by knitr is then processed by 'pandoc' (http://pandoc.org), which is responsible for 
    ### creating the finished file.
  ## The advantage of this two-step workflow is that you can create a very wide range of output formats, as you'll learn in chap. 23

  ## To get started with your own .Rmd file, select 'File -> New File -> R Markdown' in the menu bar.
  ## RStudio will launch a wizard that you can use to pre-populate your file with useful content that reminds you
    ### how the key features of R Markdown work.

  ## The following sections dive into the three components of an R Markdown document in more detail:
  ## the Markdown text, the code chunks and the YAML header.



# TEXT FORMATTING WITH MARKDOWN 

  ## Prose in .Rmd files is written in Markdown, a lightweight set of conventions for formatting plain-text files.
  ## Markdown is designed to be easy to read and easy to write. It is also very easy to learn.
  ## You can see the reference sheet with 'Help -> Markdown Quick Reference'


# CODE CHUNKS

  ## To run code inside an R Markdown document, you need to insert a chunk.
  ## There are three ways to do so:
  
  ## 1. Ctrl-Alt-I
  ## 2. The 'Insert' button icon in the editor toolbar
  ## 3. By manually typing the chunk delimiter ```{r} and ```

  ## Obviously, I'd recommend you learn the keyboard shortcut.

  ## You can continue to run the code using the keyboard shortcurt: Ctrl-Enter
  ## However, chunks get a new keyboard shortcut: Ctrl-Shift-Enter, which runs all the code in the chunk.
  ## Think of a chunk like a function.
  ## A chunk should be relatively self-contained, and focused aorund a single task.

  ## The following sections describe the chunk header, which consists of ``` {r, followed by an optional chunk name, 
    ### followed by comma-separated options, followed by }.
  ## Next comes your R code and the chunk end is indicated by a final ```.


# CHUNK NAME

  ## Chunks can be given an optional name: ```{r by-name}. This has three advantages:

  ## You can more easily navigate to specific chunks using the drop-down code navigator in the bottom-left of the script editor.
  ## Graphics produced by the chunks will have useful names that make them easier to use elsewhere.
  ## You can set up networks of cached chunks to avoid reperforming expensive computations on every run. More on that in a bit.

  ## There is one chunk name that umbues special behavior: 'setup'.
  ## When you're in a notebook mode, the chunk named 'setup' will be run automatically one, before any other code is run.


# CHUNK OPTIONS

  ## Chunk output can be customized with options, arguments supplied to the chunk header.
  ## knitr provides almost 60 options that you can use to customize your code chunks.
  ## Here we'll cover the most important cunk options that you'll use frequently.
  ## You can see the full list at http://yihui.name/knitr/options

  ## The most important set of options controls if your code block is executed 
    ### and what results are inserted in the finished report:

  ## eval = FALSE prevents code from being evaluated (if the code is not run, no results will be generated).
    ### This is useful for displaying example code, or for disabling a large block of code without commenting each line.

  ## include = FALSE runs the code, but doesn't show the code or results in the final document.
    ### Use this for setup code that you don't want cluttering your report.

  ## echo = FALSE prevents code, but not the results from appearing in the finished file.
    ### Use this when writing reports aimed at people who don't want to see the underlying R code.

  ## message = FALSE or warning = FALSE prevents messages or warning from appearing in the finished file.
  
  ## results = 'hide' hides printed output; fig.show = 'hide' hides plots.

  ## error = TRUE causes the render to continue even if code returns an error.
    ### This is rarely something you'll want to include in the final version of your report.
    ### But it's useful if you're teaching R and want to deliberately include an error.
    ### The default, error = FALSE, causes knitting to fail if there's a single error in the document.


# TABLE

  ## By default, R Markdown prints data frames and matrices as you'd see them in the console:

mtcars[1:5, 1:10]

  ## If you prefer that data be displayed with additional formatting you can use the knitr::kable function:

knitr::kable(
  mtcars[1:5, ],
  caption = "A knitr table"
)

  ## Read the document for ?knitr::table to see the other ways in which you customize the table.
  ## For even deep customization, consider the:
    ### xtable, stargazer, pander, tables and ascii packages.
  ## Each provides a set of tools for returning formatted tables from R code.



# CACHING


  ## Normally, each knit of a document starts from a completely clean slate.
  ## This is great for reproducibility, because it ensures that you've captured every important computation in code.
  ## However, it can be painful if you have some cumputations that take a long time.
  ## The solution is cache = TRUE. 
  ## When set, this will save the output of the chunk to a specially named file on disk.
  ## On subsequent runs, knitr will check to see if the code has changed, and if it hasn't, it will reuse the cached results.

  ## The caching system must be used with care, because by default it is based on the code only, not its dependencies.
  ## For example, here the processed_data chunk depends on the raw_date chunk:

    ### ``` {r raw_data}
    ### rawdata <- read_csv("file.csv")
    ### ```

    ### ``` {r processed_data, cached = TRUE}
    ### processed_data <- rawdata %>% filter(...)
    ### ```

  ## Caching the processed_data chunk means that it will get rerun if the dplyr pipeline is changed,
    ### but it won't get rerun if the read_csv() call changes.
  ## You can avoid that problem with the dependson chunk option:

    ### ``` {r processed_data, cached = TRUE, dependson = "raw_data"}
    ### processed_data <- rawdata %>% filter(...)
    ### ```


  ## dependson should contain a character vector of every chunk that the cached chunk depends on.
  ## knitr will update the results for the cached chunk whenever it detects that one of its dependencies has changed.

  ## Note that chunks won't update if file.csv changes, because knitr caching only tracks changes within the .Rmd file.
  ## If you want to also track changes to that file you can use the cache.extra option. 
  ## This is an arbitrary R expression that will invalidate the cache whenever it changes.
  ## A good function to use is file.info(): it returns a bunch of information about the file including when it was last modified.
  ## Then you can write:

    ### ``` {r raw_date, cache.extra = file.info("file.csv")}
    ### rawdata <- read_csv("file.csv")

  ## As your caching strategies get progressively more complicated, it's a good idea to regularly clear out all 
    ### your caches with knitr::clean_cache().

  ## See the advices of David Robinson (http://bit.ly/DavidRobinsonTwitter) to name these chunks.


# GLOBAL OPTIONS

  ## As you work more with knitr, you will discover that some of the default chunk options don't fit your needs, and want to change them.
  ## You can do that by calling knitr::opts_chunk$set() in a code chunk.
  ## For example, when writing books and tutorials I set:

knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE)

  ## This uses my preferred comment formatting, and ensures that the code and output are kept closely entwined.
  ## On the other hand, if you were preparing a report, you might set:

knitr::opts_chunk$set(
  echo = FALSE)

  ## That will hide the code by default, only showing the chunks you deliberately choose to show (with echo = TRUE).
  ## You might consider message = FALSE and warning = FALSE, but that would make it harder to debug problems 
    ### because you wouldn't see any messages in the final document.



# INLINE CODE

  ## There's one other way to ebed R code into an R Markdown document:
    ### directly into the text, with `r `. 
  ## This can be very useful if you mention properties of your data in the text.
  ## For example, the text "We have about `r nrow(diamonds)` diamonds."
    ### Will appear as "we have about 53940 diamonds."

  ## When inserting numbers into text, format() is your friend.
  ## It allows you to set the number of digits so you don't print to a high degree of accuracy, 
  ## and a big.mark to make numbers easier to read.

comma <- function(x) format(x, digits = 2, big.mark = ",")
comma(3452345)
comma(.123548432)


# TROUBLESHOOTING

  ## Troubleshooting R Markdown documents can be challenging because you are no longer in an interactive R environment,
  ## and you will need to learn some new tricks.

  ## The first thing you should always try is to re-create the problem in an interactive session.
  ## Restart R, then "Run all chunks" (Code -> Run region -> Run all chunks), or Ctrl-Alt-R.
  ## If you're lucky, that will re-create the problem, and you can figure out what's going on interactively.

  ## If that doesn't help, there must be something different between your interactive environment and the R Markdown environment.
  ## You're going to need to systematically explore the options.
  ## The most common difference is the working directory: the working directory of an R Markdown document is the directory in which it lives.
  ## Check that the working directory is what you expect by including getwd() in a chunk.

  ## Next, brainstorm all of the things that might cause the bug.
  ## You'll need to systematically check that they're the same in your R sessions and your R Markdown session.
  ## The easiest way to do that is to set error = TRUE on the chunk causing the problem, then use print() and str()
    ### to check that settings are as you expect.


# YAML HEADER

  ## You can control many other "whole document" settings by tweaking the parameters of the YAML header.
  ## You might wonder what YAML stands for: it's "yet another markup language", which is designed for representing
    ### hierarchical data in a way that's easy for humans to read and write.
  ## R Markdown uses it to control many details of the output. 
  ## Here we'll discuss two: document parameters and bibliographies.


# PARAMETERS

  ## R Markdown documents can include one or more parameters whose values can be set when you render the report.
  ## Parameters are useful when you want to re-render the same report with distinct values for various key inputs.
  ## For example, you might be producing sales reports per branch, exam results by student, or demographic summaries by country.
  ## To declare one or more parameters, use the 'params' field.

    ### See page 436 for an illustrative example.

  ## You can write atomic vectors directly into the YAML header. 
  ## You can also run arbitrary R expressions by prefacing the parameter value with !r.
  ## This is a good way to specify date/time parameters.


  ## In R Studio, you can click the "Knit with Parameters" option in the Knit drop-down meny to set parameters, renders,
    ### and preview the report in a single user-friendly step.
  ## You can customize the dialog by setting other options in the header.
  ## See http://bit.ly/ParamReports for more details.

  ## Alternatively, if you need to produce many such parametrized reports, you can call rmarkdown::render() with a list of params:

rmarkdown::render(
  "fuel-economy.Rmd",
  params = list(my_class = "suv"))


  ## This is particularly powerful in conjucton with purrr:pwalk(). 
  ## The following example creates a report for each value of 'class' found in 'mpg'.
  ## First we create a data frame that has one row for each class, giving the filename of report and the params it should be given:

reports <- tibble(
  class = unique(mpg$class),
  filename = stringr::str_c("fuel-economy-", class, ".html"),
  params = purrr::map(class, ~list(my_class = .)))

reports

  ## Then we match the column names to the argument names of render(), and use purrr's parallel walk to call render() once for each row:

reports %>%
  select(output_file = filename, params) %>%
  purrr::pwalk(rmarkdown::render, input = "fuel-economy.Rmd")



# BIBLIOGRAPHIES AND CITATIONS

  ## Pandoc can automatically generate citations and a bibliography in a number of styles.
  ## To use this feature, specify a bibliography file using the 'bibliography' field in your file's header.
  ## The field should contain a path from the directory that contains your .Rmd file 
    ### to the file that contains the bibliography file: 'bibliography: rmarkdown.bib'

  ## You can use many common bibliography formats including BibLaTeX, BibTeX, endnote, and medline.

    ### See page 438 for more details

# LEARNING MORE

  ## The best place to stay on top of innovations is the official R Markdown website: http://rmarkdown.rstudio.com

  ## There are two important topics that we haven't covered here:
  ## collaboration, and the details of accurately communicating your ideas to other humans.

  ## Collaboration is a vital part of modern data science, and you can make your life much easier 
  ## by using version control tools, like Git and GitHub.
  ## We recommend two free resources that will teach you about Git:

  ## "Happy Git with R": http://happygitwithr.com
  ## The "Git and GitHub" chapter of R Packages: http://r-ckgs.had.co.nz/git.html